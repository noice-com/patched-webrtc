From f7d3a4924a02bb7ea89c0a0ff9f41f9e36efb394 Mon Sep 17 00:00:00 2001
From: Antti Tapaninen <aet@aet.fi>
Date: Thu, 26 Oct 2023 14:36:22 +0300
Subject: [PATCH] Don't ask camera permission if audio session mode is playback

Co-authored-by: mekya <ahmetmermerkaya@gmail.com>
---
 .../src/audio/voice_processing_audio_unit.mm  | 108 +++++++++++-------
 1 file changed, 66 insertions(+), 42 deletions(-)

diff --git a/sdk/objc/native/src/audio/voice_processing_audio_unit.mm b/sdk/objc/native/src/audio/voice_processing_audio_unit.mm
index 3905b6857a..5661ab455a 100644
--- a/sdk/objc/native/src/audio/voice_processing_audio_unit.mm
+++ b/sdk/objc/native/src/audio/voice_processing_audio_unit.mm
@@ -112,16 +112,23 @@ static OSStatus GetAGCState(AudioUnit audio_unit, UInt32* enabled) {
   }
 
   // Enable input on the input scope of the input element.
-  UInt32 enable_input = 1;
-  result = AudioUnitSetProperty(vpio_unit_, kAudioOutputUnitProperty_EnableIO,
-                                kAudioUnitScope_Input, kInputBus, &enable_input,
-                                sizeof(enable_input));
-  if (result != noErr) {
-    DisposeAudioUnit();
-    RTCLogError(@"Failed to enable input on input scope of input element. "
-                 "Error=%ld.",
-                (long)result);
-    return false;
+  RTCAudioSessionConfiguration* webRTCConfiguration = [RTCAudioSessionConfiguration webRTCConfiguration];
+
+  if (webRTCConfiguration.mode != AVAudioSessionModeMoviePlayback) {
+    RTCLog(@"Enable input on the input scope of the input element.");
+    UInt32 enable_input = 1;
+    result = AudioUnitSetProperty(vpio_unit_, kAudioOutputUnitProperty_EnableIO,
+                                  kAudioUnitScope_Input, kInputBus, &enable_input,
+                                  sizeof(enable_input));
+    if (result != noErr) {
+      DisposeAudioUnit();
+      RTCLogError(@"Failed to enable input on input scope of input element. "
+                   "Error=%ld.",
+                  (long)result);
+      return false;
+    }
+  } else {
+    RTCLog(@"Not Enable input on the input scope of the input element.");
   }
 
   // Enable output on the output scope of the output element.
@@ -155,34 +162,45 @@ static OSStatus GetAGCState(AudioUnit audio_unit, UInt32* enabled) {
 
   // Disable AU buffer allocation for the recorder, we allocate our own.
   // TODO(henrika): not sure that it actually saves resource to make this call.
-  UInt32 flag = 0;
-  result = AudioUnitSetProperty(
-      vpio_unit_, kAudioUnitProperty_ShouldAllocateBuffer,
-      kAudioUnitScope_Output, kInputBus, &flag, sizeof(flag));
-  if (result != noErr) {
-    DisposeAudioUnit();
-    RTCLogError(@"Failed to disable buffer allocation on the input bus. "
-                 "Error=%ld.",
-                (long)result);
-    return false;
+  if (webRTCConfiguration.mode != AVAudioSessionModeMoviePlayback) {
+    RTCLog(@"Disable AU buffer allocation for the recorder, we allocate our own.");
+    UInt32 flag = 0;
+    result = AudioUnitSetProperty(
+        vpio_unit_, kAudioUnitProperty_ShouldAllocateBuffer,
+        kAudioUnitScope_Output, kInputBus, &flag, sizeof(flag));
+    if (result != noErr) {
+      DisposeAudioUnit();
+      RTCLogError(@"Failed to disable buffer allocation on the input bus. "
+                   "Error=%ld.",
+                  (long)result);
+      return false;
+    }
+  } else {
+    RTCLog(@"NOT Disable AU buffer allocation for the recorder, we allocate our own.");
   }
 
   // Specify the callback to be called by the I/O thread to us when input audio
   // is available. The recorded samples can then be obtained by calling the
   // AudioUnitRender() method.
-  AURenderCallbackStruct input_callback;
-  input_callback.inputProc = OnDeliverRecordedData;
-  input_callback.inputProcRefCon = this;
-  result = AudioUnitSetProperty(vpio_unit_,
-                                kAudioOutputUnitProperty_SetInputCallback,
-                                kAudioUnitScope_Global, kInputBus,
-                                &input_callback, sizeof(input_callback));
-  if (result != noErr) {
-    DisposeAudioUnit();
-    RTCLogError(@"Failed to specify the input callback on the input bus. "
-                 "Error=%ld.",
-                (long)result);
-    return false;
+  if (webRTCConfiguration.mode != AVAudioSessionModeMoviePlayback) {
+    RTCLog(@"Specify the callback to be called by the I/O thread to us when input audio");
+
+    AURenderCallbackStruct input_callback;
+    input_callback.inputProc = OnDeliverRecordedData;
+    input_callback.inputProcRefCon = this;
+    result = AudioUnitSetProperty(vpio_unit_,
+                                  kAudioOutputUnitProperty_SetInputCallback,
+                                  kAudioUnitScope_Global, kInputBus,
+                                  &input_callback, sizeof(input_callback));
+    if (result != noErr) {
+      DisposeAudioUnit();
+      RTCLogError(@"Failed to specify the input callback on the input bus. "
+                   "Error=%ld.",
+                  (long)result);
+      return false;
+    }
+  } else {
+    RTCLog(@"NOT Specify the callback to be called by the I/O thread to us when input audio");
   }
 
   state_ = kUninitialized;
@@ -204,15 +222,21 @@ static OSStatus GetAGCState(AudioUnit audio_unit, UInt32* enabled) {
   LogStreamDescription(format);
 #endif
 
-  // Set the format on the output scope of the input element/bus.
-  result =
-      AudioUnitSetProperty(vpio_unit_, kAudioUnitProperty_StreamFormat,
-                           kAudioUnitScope_Output, kInputBus, &format, size);
-  if (result != noErr) {
-    RTCLogError(@"Failed to set format on output scope of input bus. "
-                 "Error=%ld.",
-                (long)result);
-    return false;
+  RTCAudioSessionConfiguration* webRTCConfiguration = [RTCAudioSessionConfiguration webRTCConfiguration];
+  if (webRTCConfiguration.mode != AVAudioSessionModeMoviePlayback) {
+    RTCLog(@"Setting the format on the output scope of the input element/bus because it's not movie mode");
+    // Set the format on the output scope of the input element/bus.
+    result =
+        AudioUnitSetProperty(vpio_unit_, kAudioUnitProperty_StreamFormat,
+                             kAudioUnitScope_Output, kInputBus, &format, size);
+    if (result != noErr) {
+      RTCLogError(@"Failed to set format on output scope of input bus. "
+                   "Error=%ld.",
+                  (long)result);
+      return false;
+    }
+  } else {
+    RTCLog(@"NOT setting the format on the output sscope of the input element because it's movie mode");
   }
 
   // Set the format on the input scope of the output element/bus.
-- 
2.39.3 (Apple Git-145)

